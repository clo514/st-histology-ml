---
title: "R Notebook"
output: html_notebook
---
# Exploratory Data Analysis
In this markdown, exploratory data analysis is performed on sample 151507, with the goal of discovering genes whose expression values are correlated with simple histology image features (RGB/Grayscale color space). Sample 151507 includes 4136 spots and 21131 genes after performing QC on spots and removing genes with an expression level of 0 for all spots. 

First, RGB/grayscale color channels are extracted from the image. All images are in lowres, meaning that they each have size 600 x 600. Then, the 4136 x 9 dataframe 'data' is created. Each row of data represents a barcode/spot, and the following column data is represented: <br />

"pxl_col_in_fullres": column number of barcode in fullres image <br />
"pxl_row_in_fullres": row number of barcode in fullres image <br />
"barcode": string containing barcode <br />
"scaled_pxl_col_in_lowres": column number of barcode in lowres image <br />
"scaled_pxl_row_in_lowres": row number of barcode in lowres image <br />
"red": red channel value of barcode <br />
"green": green channel value of barcode <br />
"blue": blue channel value of barcode <br />
"grey": grey channel value of barcode <br />

Then, correlation + the removal of outliers is performed in two ways, with the second being optimal.
1. Correlation between gene expression values and RGB/Grayscale pixel values is performed; then, outlier pixel and gene expression values are removed.
2. Outliers are removed first, then correlation is performed.
### Imports
```{r, message=FALSE}
library(spatialLIBD)
library(scuttle)
library(dplyr)
library(ggcorrplot)
library(ggplot2)
library(EBImage)
library(ggpubr)
library(foreach)
library(doParallel)
registerDoParallel(4)
```


### Remove Genes that have gene expression of 0 across all spots
```{r, message=FALSE}
# create boolean array for logcounts
logcounts_151507 <- logcounts(spe_sub)

# transpose logcounts matrix
logcounts_151507 <- t(logcounts_151507)

# remove genes that have a max gene expression of 0 across all spots
zv <- apply(logcounts_151507, 2, function(x) length(unique(x)) == 1)
logcounts_151507_filtered <- as.matrix(logcounts_151507[,!zv])

# after filtering, 12407 genes are removed and 21131 are left over
dim(logcounts_151507)
dim(logcounts_151507_filtered)
```


### Create RGB color channels and plot histograms of distribution
```{r, message=FALSE}
png_link <- imgData(spe)[imgData(spe)$sample_id == sample_id,]$data[1]
img <- readImage('https://spatial-dlpfc.s3.us-east-2.amazonaws.com/images/151507_tissue_lowres_image.png')

# create 600x600 color channel matrices for each channel
red <- imageData(EBImage::channel(img, 'red'))
green <- imageData(EBImage::channel(img, 'green'))
blue <- imageData(EBImage::channel(img, 'blue'))
grey <- imageData(EBImage::channel(img, 'grey'))

# visualize histograms of each color channel
hist(red)
hist(green)
hist(blue)
hist(grey)

#display(red)
#display(green)
#display(blue)
```

### Create DF Holding Pixel Coordinates and Pixel Color Channel Values Per Spot
```{r, message=FALSE}
# get scale factor
scaling <- SpatialExperiment::scaleFactors(spe_sub)

# store spatial coords information (pxl col and row numbers in fullres image for each barcode)
spatial_coords <- spatialCoords(spe_sub)

# create data frame to hold pixel locations and pixel color channel values
data <- data.frame(spatial_coords, row.names=NULL)
data['barcode'] <- rownames(spatial_coords)

# add scaled pixel columns
new <- ceiling(data[["pxl_col_in_fullres"]] * scaling)
data[ , ncol(data) + 1] <- new 
colnames(data)[ncol(data)] <- "scaled_pxl_col_in_lowres"

# add scaled pixel rows
new <- ceiling(data[["pxl_row_in_fullres"]] * scaling)
data[ , ncol(data) + 1] <- new 
colnames(data)[ncol(data)] <- "scaled_pxl_row_in_lowres"

# create vectors to be added to dataframe
X_r <- vector(mode="double", length = dim(data)[1])
X_g <- vector(mode="double", length = dim(data)[1])
X_b <- vector(mode="double", length = dim(data)[1])
X_grey <- vector(mode="double", length = dim(data)[1])

# iterate over dataframe, add rgb values
for (i in 1:nrow(data)) {
    col_index <- data[i,]$scaled_pxl_col_in_lowres
    row_index <- data[i,]$scaled_pxl_row_in_lowres
    X_r[i] <- red[col_index, row_index]
    X_g[i] <- green[col_index, row_index]
    X_b[i] <- blue[col_index, row_index]
    X_grey[i] <- grey[col_index, row_index]
}

data[ , ncol(data) + 1] <- X_r
colnames(data)[ncol(data)] <- "red"
data[ , ncol(data) + 1] <- X_g
colnames(data)[ncol(data)] <- "green"
data[ , ncol(data) + 1] <- X_b
colnames(data)[ncol(data)] <- "blue"
data[ , ncol(data) + 1] <- X_grey
colnames(data)[ncol(data)] <- "grey"
```

```{r, message=FALSE}
dim(data)
data
```


### Functions for high res images, where there exist more than one pixel per spot
```{r, message=FALSE}
# Mode Function
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

# For a spot 'i', plot histogram of pixel color values given by 'color'
plot_pixels_per_spot <- function(ind_barcodes, data, color, i) {
  # histogram of color channel values in one spot
  barcode = rownames(ind_barcodes)[i]
  x <- data[data$barcode == barcode, color]
  hist(x, main=paste("Histogram of ",  color, " Color Channel Values For a Single Barcode", sep = ''),breaks=100)
}

# Create a df where rows are barcodes and columns are mean, median, and mode values for each RGB/Grayscale category
populate_ind_barcodes <- function(i, ind_barcodes) {
  colors <- c("red", "green", "blue", "grey")
  for (j in 1:length(colors)) {
    color <- colors[j]
    vals <- data[data$barcode == row.names(ind_barcodes)[i],][,color]
    ind_barcodes[i, paste("mean_", color, sep="")] <- mean(vals)
    ind_barcodes[i, paste("median_", color, sep="")] <- median(vals)
    ind_barcodes[i, paste("mode_", color, sep="")] <- getmode(vals) 
  }
  ind_barcodes
}

# create empty df
ind_barcodes <- data.frame(matrix(ncol = 12, nrow = length(unique(data[,'barcode']))))
colnames(ind_barcodes) <- c('mean_red', 'median_red', 'mode_red', 'mean_green', 'median_green', 'mode_green', 'mean_blue', 'median_blue', 'mode_blue', 'mean_grey', 'median_grey', 'mode_grey')
rownames(ind_barcodes) <- unique(data[, 'barcode'])

# add mean, median, mode data
for (i in 1:nrow(ind_barcodes)) {
 ind_barcodes <- populate_ind_barcodes(i, ind_barcodes)
}
ind_barcodes
```

### Analysis 1: Compute Correlation First, Compute Outliers After
In the following blocks, the correlation between all genes + pixel color channel values is calculated. Then, for the top performing genes, a plotting function is called in which spots corresponding to outlier gene expression values + spots corresponding to outlier pixel color channel values are removed.


```{r, message=FALSE}
# compute correlation matrix in parallel
compute_corr_matrix <- function(expression_arr, color_arr, round=4) {
  foreach(i = 1:ncol(expression_arr),
  .combine = rbind,
  .packages = c('data.table', 'doParallel')) %dopar% {
    colName <- colnames(expression_arr)[i]
    df <- data.frame(round(cor(expression_arr[,i], color_arr, method = 'pearson', use="complete.obs"), round))
    rownames(df) <- colName
    df
  }
}

# Filter correlation matrix based on a threshold and replace gene IDs with gene names
filter_corr_matrix <- function(correlation_matrix, threshold) {
  filter <- as.data.frame(apply(abs(correlation_matrix) >= threshold, 1, any))
  correlation_matrix_filtered <- correlation_matrix[filter[,1],]
  correlation_matrix_filtered <- rename_gene_ids(correlation_matrix_filtered)
  correlation_matrix_filtered
}

# Replace gene IDs with gene names
rename_gene_ids <- function(correlation_matrix) {
  for (i in 1:nrow(correlation_matrix)) {
    g_name <- rownames(correlation_matrix)[i]
    rownames(correlation_matrix)[i] <- rowData(spe_sub[g_name])$gene_name
  }
  correlation_matrix
}

# Plot correlation matrix
plot_corr_matrix <- function(correlation_matrix) {
  ggcorrplot(correlation_matrix, sig.level=0.01, lab_size = 4.5, p.mat = NULL,
           insig = c("pch", "blank"), pch = 1, pch.col = "black", pch.cex =1,
           tl.cex = 7) +
  theme(axis.text.x = element_text(margin=margin(-2,0,0,0)),
        axis.text.y = element_text(margin=margin(0,-2,0,0)),
        panel.grid.minor = element_line(size=7)) + 
  geom_tile(fill="white") +
  geom_tile(height=1, width=1)
}

# function to calculate regression equation. Used as a sanity check
lm_eqn <- function(vec1, vec2){
    m <- lm(vec1 ~ vec2, data.frame(vec1, vec2));
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(unname(coef(m)[1]), digits = 2),
              b = format(unname(coef(m)[2]), digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}
```

```{r, message=FALSE}
color_arr <- data[,6:ncol(data)]
correlation_matrix <- compute_corr_matrix(logcounts_151507_filtered, color_arr)
correlation_matrix_filtered <- filter_corr_matrix(correlation_matrix, 0.3)
plot_corr_matrix(correlation_matrix_filtered)
```


```{r, message=FALSE}
# plot color channel value vs gene expression. If remove_outliers == TRUE, outlier gene expression values + outlier pixel color values are removed.
# ASSUMES THAT EACH BARCODE HAS MULTIPLE PIXELS
plot_channel_highres <- function(g_name, gene_id, color, stat, log_arr, color_arr, remove_outliers) {
  stat_type <- paste(color, stat, sep="_")
  x_axis <- log_arr[,gene_id]
  y_axis <- color_arr[,stat_type] * 255
  df <- data.frame(x_axis, y_axis)
  if (remove_outliers) {
    barcode_names <- rownames(log_arr)
    overlap <- union(rownames(log_arr)[isOutlier(log_arr[,gene_id])], rownames(color_arr)[isOutlier(color_arr[,stat_type])])
    rownames(df) <- barcode_names
    df <- df[-which(rownames(df) %in% overlap),]
    title <- paste(stat_type, " Channel Values vs ", g_name, " Gene Expression with Outliers Removed", sep="")
  } else {
    title <- paste(stat_type, " Channel Values vs ", g_name, " Gene Expression without Outliers Removed", sep="")
  }
  ggplot(df, aes(x=df[,1], y=df[,2])) + xlab(g_name) + ylab(stat_type) + geom_point(color=color) +
  geom_smooth(method='lm', color='black') + stat_regline_equation(label.y = 190, aes(label = ..eq.label..)) +
  stat_regline_equation(label.y = 180, aes(label = ..rr.label..)) + ggtitle(title) 
}

# call plot_channel function for all color and mean/median/mode combinations
# ASSUMES THAT EACH BARCODE HAS MULTIPLE PIXELS
plot_all_channels_highres <- function(g_name, log_arr, color_arr, remove_outliers) {
  gene_id <- rowData(spe)[rowData(spe)$gene_name == g_name,]$gene_id
  colors <- c('red', 'green', 'blue', 'grey')
  stats <- c('mean', 'median', 'mode')

  for (color in colors) {
    for (stat in stats) {
      print(plot_channel_highres(g_name, gene_id, color, stat, log_arr, color_arr, remove_outliers)) 
    }
  }
}

# plot color channel value vs gene expression. If remove_outliers == TRUE, outlier gene expression values + outlier pixel color values are removed.
# ASSUMES THAT EACH BARCODE HAS ONE PIXEL
plot_channel <- function(g_name, gene_id, color, log_arr, color_arr, remove_outliers) {
  x_axis <- log_arr[,gene_id]
  y_axis <- color_arr[,color] * 255
  df <- data.frame(x_axis, y_axis)
  if (remove_outliers) {
    barcode_names <- rownames(log_arr)
    overlap <- union(rownames(log_arr)[isOutlier(log_arr[,gene_id])], rownames(color_arr)[isOutlier(color_arr[,color])])
    rownames(df) <- barcode_names
    df <- df[-which(rownames(df) %in% overlap),]
    title <- paste(color, " Channel Values vs ", g_name, " Gene Expression with Outliers Removed", sep="")
  } else {
    title <- paste(color, " Channel Values vs ", g_name, " Gene Expression without Outliers Removed", sep="")
  }
  ggplot(df, aes(x=df[,1], y=df[,2])) + xlab(g_name) + ylab(color) + geom_point(color=color) +
  geom_smooth(method='lm', color='black') + stat_regline_equation(label.y = 190, aes(label = ..eq.label..)) +
  stat_regline_equation(label.y = 180, aes(label = ..rr.label..)) + ggtitle(title) 
}

# call plot_channel function for all colors
# ASSUMES THAT EACH BARCODE HAS ONE PIXEL
plot_all_channels <- function(g_name, log_arr, color_arr, remove_outliers) {
  gene_id <- rowData(spe)[rowData(spe)$gene_name == g_name,]$gene_id
  colors <- c('red', 'green', 'blue', 'grey')

  for (color in colors) {
    print(plot_channel(g_name, gene_id, color, log_arr, color_arr, remove_outliers))
  }
}
```

```{r, message=FALSE}
plot_all_channels('MT-ND1', logcounts_151507_filtered, color_arr, remove_outliers=FALSE)
plot_all_channels('MT-ND1', logcounts_151507_filtered, color_arr, remove_outliers=TRUE)
```

```{r, message=FALSE}
plot_all_channels('MT-CO2', logcounts_151507_filtered, color_arr, remove_outliers=FALSE)
plot_all_channels('MT-CO2', logcounts_151507_filtered, color_arr, remove_outliers=TRUE)
```
```{r, message=FALSE}
plot_all_channels('MT-ATP6', logcounts_151507_filtered, color_arr, remove_outliers=FALSE)
plot_all_channels('MT-ATP6', logcounts_151507_filtered, color_arr, remove_outliers=TRUE)
```
```{r, message=FALSE}
plot_all_channels('MT-CYB', logcounts_151507_filtered, color_arr, remove_outliers=FALSE)
plot_all_channels('MT-CYB', logcounts_151507_filtered, color_arr, remove_outliers=TRUE)
```


## Redo Analysis Removing Outliers Before Correlation Computation
In the following blocks, analysis is redone by removing outliers before correlation computation based on the isOutlier() function. If the number of non-NA expression values < num = 100, the gene is removed from consideration. Then, correlation between the RGB/Grayscale values and gene expression values is computed. 
```{r, message=FALSE}
# Remove outlier gene expression values. If median gene expression value is 0, replace complement of outliers with NA. Else replace outliers with NA. If remaining non-NA expression values < num, replace entire column with NA.
remove_outliers <- function(arr, num) {
  foreach(i = 1:ncol(arr),
  .combine = cbind,
  .packages = c('data.table', 'doParallel')) %dopar% {
    if (median(arr[,i]) == 0) {
      arr[,i][!isOutlier(arr[,i])] <- NA
    } else {
      arr[,i][isOutlier(arr[,i])] <- NA
    }
    if (matrixStats::count(!is.na(arr[,i])) < num) {
      arr[,i] <- rep(NA, nrow(arr))
    }
    arr[,i]
  }
}

get_top_k_corr <- function(mat, k) {
  top_corr_ind <- unique(c(order(abs(mat[,1]),decreasing=T)[1:k], 
                         order(abs(mat[,2]),decreasing=T)[1:k], 
                         order(abs(mat[,3]),decreasing=T)[1:k], 
                         order(abs(mat[,4]),decreasing=T)[1:k]))
  top_corr <- rename_gene_ids(mat[top_corr_ind,])
  top_corr
}
```

```{r, message=FALSE}
# Call remove outlier function
logcounts_temp <- as.matrix(logcounts_151507_filtered)
col_names <- colnames(logcounts_temp)
logcounts_151507_filtered_no_outliers <- remove_outliers(logcounts_temp, 100)
colnames(logcounts_151507_filtered_no_outliers) <- col_names

# Remove columns that are completely NA
not_all_na <- function(x) any(!is.na(x))
logcounts_151507_filtered_no_outliers <- data.frame(logcounts_151507_filtered_no_outliers) %>% select(where(not_all_na))

# compute correlation matrix
mat <- compute_corr_matrix(logcounts_151507_filtered_no_outliers, color_arr)
```


```{r, message=FALSE}
top_corr <- get_top_k_corr(mat, 10)
plot_corr_matrix(top_corr)
```

```{r, message=FALSE}
plot_all_channels('LFNG', logcounts_151507_filtered_no_outliers, color_arr, remove_outliers=FALSE)
```
```{r, message=FALSE}
plot_all_channels('ELK4', logcounts_151507_filtered_no_outliers, color_arr, remove_outliers=FALSE)
```
```{r, message=FALSE}
plot_all_channels('PLIN4', logcounts_151507_filtered_no_outliers, color_arr, remove_outliers=FALSE)
```


